<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>rgbd_tools: Setting up a simple Extended Kalman filter for 2D object tracking</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rgbd_tools
   &#160;<span id="projectnumber">0.2.2</span>
   </div>
   <div id="projectbrief">General purpose tools for stereo devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Setting up a simple Extended Kalman filter for 2D object tracking </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page shows how to use the abstract templatized implementation of the Extended Kalman Filter from RGBD_TOOLS. Extended Kalman Filter(or EKF) is a nonlinear estate estimator. For deeper understanding it is recomended to dig on internet. A good tutorial can be found in the following <a href="https://www.cse.sc.edu/~terejanu/files/tutorialEKF.pdf">link</a></p>
<p>Let's consider a nonlinear system, it is possible to model it by the system model and observation model </p><div class="fragment"><div class="line">x_k = f(x_k-1) + w_k-1</div><div class="line">z_k = h(x_k) + v_k</div></div><!-- fragment --><p>The library offers a parent class which can be inherited and implements all the EKF procedure. It is only needed to implementation the update of the system jacobian and the observation model according to your specific problem. Following code shows an example of implementation for simple kinematic 2D simple which observation model is its position with some noise.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rgbd_tools/state_filtering/ExtendedKalmanFilter.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;opencv2/opencv.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Simple2DEKF: <span class="keyword">public</span> <a class="code" href="classrgbd_1_1_extended_kalman_filter.html">rgbd::ExtendedKalmanFilter</a>&lt;float,4,2&gt; {</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="comment">//---------------------------------------------------------------------------------------------------</span></div><div class="line">    <span class="keywordtype">void</span> updateJf(<span class="keyword">const</span> <span class="keywordtype">double</span> _incT){</div><div class="line">         mJf.setIdentity();</div><div class="line">         mJf.block&lt;2,2&gt;(0,2) = Eigen::Matrix&lt;float,2,2&gt;::Identity()*_incT;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//---------------------------------------------------------------------------------------------------</span></div><div class="line">    <span class="keywordtype">void</span> updateHZk(){</div><div class="line">        mHZk = mXak.block&lt;2,1&gt;(0,0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//---------------------------------------------------------------------------------------------------</span></div><div class="line">    <span class="keywordtype">void</span> updateJh(){</div><div class="line">        mJh.setIdentity();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> _argc, <span class="keywordtype">char</span> **_argv){</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> NOISE_LEVEL = 0.1;</div><div class="line"></div><div class="line">    Eigen::Matrix&lt;float, 4, 4&gt; mQ; <span class="comment">// State covariance</span></div><div class="line">    mQ.setIdentity();   </div><div class="line">    mQ.block&lt;2,2&gt;(0,0) *= 0.01;</div><div class="line">    mQ.block&lt;2,2&gt;(2,2) *= 0.03;</div><div class="line"></div><div class="line">    Eigen::Matrix&lt;float, 2, 2&gt; mR; <span class="comment">// Observation covariance</span></div><div class="line">    mR.setIdentity();   </div><div class="line">    mR.block&lt;2,2&gt;(0,0) *= NOISE_LEVEL*2;</div><div class="line"></div><div class="line">    Eigen::Matrix&lt;float, 4,1&gt; x0;</div><div class="line">    x0 &lt;&lt;   1,0,    <span class="comment">// (x,y)</span></div><div class="line">            0,0;    <span class="comment">// (v_x, v_y)</span></div><div class="line">    </div><div class="line">    Simple2DEKF ekf;</div><div class="line"></div><div class="line">    ekf.setUpEKF(mQ, mR, x0);</div><div class="line">    cv::Mat map = cv::Mat::zeros(cv::Size(300, 300), CV_8UC3);</div><div class="line"></div><div class="line">    cv::namedWindow(<span class="stringliteral">&quot;display&quot;</span>, CV_WINDOW_FREERATIO);</div><div class="line">    cv::Point2f prevObs(250, 150), prevState(250, 150);</div><div class="line"></div><div class="line">    <span class="keywordtype">float</span> fakeTimer = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(<span class="keyword">true</span>){</div><div class="line">        Eigen::Matrix&lt;float, 2,1&gt; z;    <span class="comment">// New observation</span></div><div class="line">        z &lt;&lt;    0.5 + cos(fakeTimer*1)*0.5 + ((double)rand())/RAND_MAX*NOISE_LEVEL,</div><div class="line">                0.5 + sin(fakeTimer*1)*0.5 + ((double)rand())/RAND_MAX*NOISE_LEVEL;</div><div class="line"></div><div class="line">        fakeTimer += 0.03;</div><div class="line"></div><div class="line">        ekf.stepEKF(z, 0.03);</div><div class="line"></div><div class="line">        Eigen::Matrix&lt;float,4,1&gt; filteredX = ekf.state();</div><div class="line"></div><div class="line">        cv::Point2f currentObs(</div><div class="line">            z[0]*200 + 50,</div><div class="line">            z[1]*200 + 50</div><div class="line">        );</div><div class="line">        cv::Point2f currentState(</div><div class="line">            filteredX[0]*200 + 50,</div><div class="line">            filteredX[1]*200 + 50</div><div class="line">        );</div><div class="line"></div><div class="line">        cv::line(map, prevObs, currentObs, cv::Scalar(100,100,255));</div><div class="line">        cv::line(map, prevState, currentState, cv::Scalar(0,255,0),2);</div><div class="line"></div><div class="line">        prevObs = currentObs;</div><div class="line">        prevState = currentState;</div><div class="line">        </div><div class="line">        cv::imshow(<span class="stringliteral">&quot;display&quot;</span>, map);</div><div class="line">        cv::waitKey(30);</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>This is the example running: </p><div class="image">
<img src="ekf_2d_simple.gif" alt="ekf_2d_simple.gif"/>
</div>
<h1>Code snippets explained</h1>
<p>Include parent EKF class </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rgbd_tools/state_filtering/ExtendedKalmanFilter.h&gt;</span></div></div><!-- fragment --><p>Import other necessary header files </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;opencv2/opencv.hpp&gt;</span></div></div><!-- fragment --><p>Implementation of the child class. The parent class receive three template arguments. The first one is the numerical type for for the matrices, it can be float or double. The second one is the size of system's state and the thirdone is the size of the observation state. </p><div class="fragment"><div class="line"><span class="keyword">class </span>Simple2DEKF: <span class="keyword">public</span> <a class="code" href="classrgbd_1_1_extended_kalman_filter.html">rgbd::ExtendedKalmanFilter</a>&lt;float,4,2&gt; {</div><div class="line"><span class="keyword">protected</span>:</div></div><!-- fragment --><p>Function that updates the jacobian of the system, it receives the increment of time, if needed. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> updateJf(<span class="keyword">const</span> <span class="keywordtype">double</span> _incT){</div><div class="line">    mJf.setIdentity();</div><div class="line">    mJf.block&lt;2,2&gt;(0,2) = Eigen::Matrix&lt;float,2,2&gt;::Identity()*_incT;</div><div class="line">}</div></div><!-- fragment --><p> Function that defines how the state is observed. It transform the internal state to an observation of the internal state to compare it later with the real observed state. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> updateHZk(){</div><div class="line">    mHZk = mXak.block&lt;2,1&gt;(0,0);</div><div class="line">}</div></div><!-- fragment --><p>Computes the jacobian of the observation state. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> updateJh(){</div><div class="line">    mJh.setIdentity();</div><div class="line">}</div></div><!-- fragment --><p>Setting up covariances of the system and initial state for the EKF </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> NOISE_LEVEL = 0.1;</div><div class="line"></div><div class="line">Eigen::Matrix&lt;float, 4, 4&gt; mQ; <span class="comment">// State covariance</span></div><div class="line">mQ.setIdentity();   </div><div class="line">mQ.block&lt;2,2&gt;(0,0) *= 0.01;</div><div class="line">mQ.block&lt;2,2&gt;(2,2) *= 0.03;</div><div class="line"></div><div class="line">Eigen::Matrix&lt;float, 2, 2&gt; mR; <span class="comment">// Observation covariance</span></div><div class="line">mR.setIdentity();   </div><div class="line">mR.block&lt;2,2&gt;(0,0) *= NOISE_LEVEL*2;</div><div class="line"></div><div class="line">Eigen::Matrix&lt;float, 4,1&gt; x0;</div><div class="line">x0 &lt;&lt;   1,0,    <span class="comment">// (x,y)</span></div><div class="line">        0,0;    <span class="comment">// (v_x, v_y)</span></div><div class="line"></div><div class="line">Simple2DEKF ekf;</div><div class="line"></div><div class="line">ekf.setUpEKF(mQ, mR, x0);</div></div><!-- fragment --><p> Create an empty image to display the result </p><div class="fragment"><div class="line">cv::Mat map = cv::Mat::zeros(cv::Size(300, 300), CV_8UC3);</div><div class="line"></div><div class="line">cv::namedWindow(<span class="stringliteral">&quot;display&quot;</span>, CV_WINDOW_FREERATIO);</div><div class="line">cv::Point2f prevObs(250, 150), prevState(250, 150);</div></div><!-- fragment --><p> Get an observation and update EKF </p><div class="fragment"><div class="line">Eigen::Matrix&lt;float, 2,1&gt; z;    <span class="comment">// New observation</span></div><div class="line">z &lt;&lt;    0.5 + cos(fakeTimer*1)*0.5 + ((double)rand())/RAND_MAX*NOISE_LEVEL,</div><div class="line">        0.5 + sin(fakeTimer*1)*0.5 + ((double)rand())/RAND_MAX*NOISE_LEVEL;</div><div class="line"></div><div class="line">ekf.stepEKF(z, 0.03);</div></div><!-- fragment --><p> Retrieve filtered state and plot it </p><div class="fragment"><div class="line">Eigen::Matrix&lt;float,4,1&gt; filteredX = ekf.state();</div><div class="line"></div><div class="line">cv::Point2f currentObs(</div><div class="line">    z[0]*200 + 50,</div><div class="line">    z[1]*200 + 50</div><div class="line">);</div><div class="line">cv::Point2f currentState(</div><div class="line">    filteredX[0]*200 + 50,</div><div class="line">    filteredX[1]*200 + 50</div><div class="line">);</div><div class="line"></div><div class="line">cv::line(map, prevObs, currentObs, cv::Scalar(100,100,255));</div><div class="line">cv::line(map, prevState, currentState, cv::Scalar(0,255,0),2);</div><div class="line"></div><div class="line">prevObs = currentObs;</div><div class="line">prevState = currentState;</div><div class="line"></div><div class="line">cv::imshow(<span class="stringliteral">&quot;display&quot;</span>, map);</div><div class="line">cv::waitKey(30);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
