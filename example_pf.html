<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>rgbd_tools: Setting up a simple Particle Filter for a simple 2D bicycle robot model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rgbd_tools
   </div>
   <div id="projectbrief">General purpose tools for stereo devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Setting up a simple Particle Filter for a simple 2D bicycle robot model </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page shows how to use the abstract templatized implementation of the Particle Filter state estimation from RGBD_TOOLS. Particle Filteri is a Sequential Monte Carlo nonlinear estate estimator. For deeper understanding it is recomended to dig on internet. A good tutorial can be found in the following <a href="https://www.youtube.com/watch?v=4S-sx5_cmLU">link</a></p>
<p>RGBD_TOOLS implements a class that implement's the particle filter algorithm for CPU called ParticleFilterCPU. It is a templatized class that performs the simulation of the particles and the resampling methods. Particles are required to inherit from ParticleInterface abstract class. The observation structure can be of anykind and is part is the second template of the ParticleFilterCPU class.</p>
<p>In this tutorial, a simple 2D bicycle robot model is used. One thousand particles are simulated and then the medium value of the of the particles is used as the estimation. Additionally, the covariances can be used to estimate the uncertainty of the estimator.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;opencv2/opencv.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;rgbd_tools/state_filtering/ParticleFilterCPU.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacergbd.html">rgbd</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> WORLD_SIZE = 300;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> gauss(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp; _nu, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; _sigma) { </div><div class="line">  std::random_device rd; </div><div class="line">  std::mt19937 gen(rd()); </div><div class="line"></div><div class="line">  std::normal_distribution&lt;&gt; d(_nu, _sigma); </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> d(gen); </div><div class="line">} </div><div class="line"></div><div class="line"><span class="keyword">struct </span>ObservationData{</div><div class="line">  <span class="keywordtype">double</span> distanceOrigin = 0;</div><div class="line">  <span class="keywordtype">double</span> angle = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ParticleRobot : <span class="keyword">public</span> <a class="code" href="classrgbd_1_1_particle_interface.html">ParticleInterface</a>&lt;ObservationData&gt;{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ParticleRobot() {</div><div class="line">      mPosition[0] = gauss(WORLD_SIZE/2,25);</div><div class="line">      mPosition[1] = gauss(WORLD_SIZE/2,25);</div><div class="line">      mPosition[2] = gauss(0,1);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> simulate() { </div><div class="line">      mPosition[0] += 1*cos(mPosition[2]) + gauss(0,0.1);</div><div class="line">      mPosition[1] += 1*sin(mPosition[2]) + gauss(0,0.1);</div><div class="line">      mPosition[2] += gauss(0,0.05);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[0] &gt; WORLD_SIZE)</div><div class="line">          mPosition[0] = fmod(mPosition[0], WORLD_SIZE);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[0] &lt; 0)</div><div class="line">          mPosition[0] += WORLD_SIZE;</div><div class="line">      </div><div class="line">      <span class="keywordflow">if</span>(mPosition[1] &gt; WORLD_SIZE)</div><div class="line">          mPosition[1] = fmod(mPosition[1], WORLD_SIZE);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[1] &lt; 0)</div><div class="line">          mPosition[1] += WORLD_SIZE;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[2] &gt; M_PI*2)</div><div class="line">          mPosition[2] = fmod(mPosition[2], M_PI*2);</div><div class="line"></div><div class="line">          </div><div class="line">  };</div><div class="line"></div><div class="line">  ObservationData observation(){</div><div class="line">      <span class="keywordtype">double</span> xNoise = mPosition[0] + gauss(0,0.1);</div><div class="line">      <span class="keywordtype">double</span> yNoise = mPosition[1] + gauss(0,0.1);</div><div class="line"></div><div class="line">      ObservationData data;</div><div class="line">      data.distanceOrigin = sqrt(xNoise*xNoise + yNoise*yNoise);</div><div class="line">      data.angle = mPosition[2];</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> data;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> computeWeight(ObservationData &amp;_observation) {  </div><div class="line">      ObservationData fakeData = observation();</div><div class="line">      ObservationData realData = _observation;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> weightDistance = 1 - fabs(fakeData.distanceOrigin-realData.distanceOrigin)/WORLD_SIZE/2;</div><div class="line">      <span class="keywordtype">double</span> weightAngle = 1 - fabs(fakeData.angle - realData.angle)/(M_PI*2);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> weightAngle*weightDistance;</div><div class="line">  };</div><div class="line"></div><div class="line">  std::array&lt;double, 3&gt; position(){ <span class="keywordflow">return</span> mPosition; }</div><div class="line">  <span class="keyword">operator</span> std::array&lt;double, 3&gt;(){ <span class="keywordflow">return</span> mPosition; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::array&lt;double, 3&gt; mPosition;    <span class="comment">// x, y, ori</span></div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line">std::array&lt;double, 3&gt; mediumState(std::vector&lt;ParticleRobot&gt; _particles);</div><div class="line"><span class="keywordtype">void</span> particleFilterCPU();</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){</div><div class="line">  </div><div class="line">  particleFilterCPU();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Finished&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line">std::array&lt;double, 3&gt; mediumState(std::vector&lt;ParticleRobot&gt; _particles){</div><div class="line">  std::array&lt;double, 3&gt; position = {0.0, 0.0, 0.0};</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; _particles.size(); i++){</div><div class="line">      std::array&lt;double, 3&gt; pos = _particles[i];</div><div class="line">      position[0] += pos[0];</div><div class="line">      position[1] += pos[1];</div><div class="line">      position[2] += pos[2];</div><div class="line">  }</div><div class="line">  position[0] /= _particles.size();</div><div class="line">  position[1] /= _particles.size();</div><div class="line">  position[2] /= _particles.size();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> position;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> particleFilterCPU() {</div><div class="line"></div><div class="line">  <a class="code" href="classrgbd_1_1_particle_filter_c_p_u.html">ParticleFilterCPU&lt;ParticleRobot, ObservationData&gt;</a> filter(1000);</div><div class="line">  filter.init();</div><div class="line"></div><div class="line">  ParticleRobot robot;</div><div class="line">  <span class="keywordtype">double</span> time = 0.0;</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> cScaleFactor=1;</div><div class="line"></div><div class="line">  cv::namedWindow(<span class="stringliteral">&quot;display&quot;</span>, CV_WINDOW_FREERATIO);</div><div class="line">  <span class="keywordflow">for</span> (;;) {</div><div class="line">      std::array&lt;double, 3&gt; medState = mediumState(filter.particles());</div><div class="line">      std::array&lt;double, 3&gt; realState = robot.position();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;-------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Real state. X:&quot;</span> &lt;&lt; realState[0] &lt;&lt; <span class="stringliteral">&quot; ; Y: &quot;</span> &lt;&lt; realState[1] &lt;&lt; <span class="stringliteral">&quot; ; Ori: &quot;</span> &lt;&lt; realState[2] &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Promediate state. X:&quot;</span> &lt;&lt; medState[0] &lt;&lt; <span class="stringliteral">&quot; ; Y: &quot;</span> &lt;&lt; medState[1] &lt;&lt; <span class="stringliteral">&quot; ; Ori: &quot;</span> &lt;&lt; medState[2] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      cv::Mat display(WORLD_SIZE, WORLD_SIZE, CV_8UC3, cv::Scalar(0,0,0));</div><div class="line">      <span class="comment">// Draw landmarks</span></div><div class="line">      </div><div class="line">      cv::circle(display, cv::Point2i(WORLD_SIZE/2, WORLD_SIZE/2), 3, cv::Scalar(0,0,255), 3);</div><div class="line"></div><div class="line">      <span class="comment">// Draw particles</span></div><div class="line">      <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;particle: filter.particles()){</div><div class="line">          std::array&lt;double, 3&gt; pos = particle;</div><div class="line">          cv::arrowedLine(display,    cv::Point2i(pos[0]*cScaleFactor, pos[1]*cScaleFactor), </div><div class="line">                                      cv::Point2i(pos[0]*cScaleFactor, pos[1]*cScaleFactor) + cv::Point2i(cos(realState[2])*5*cScaleFactor, sin(realState[2])*5*cScaleFactor), </div><div class="line">                                      cv::Scalar(255,0,0), 1);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// Draw robot</span></div><div class="line">      cv::arrowedLine(display,    cv::Point2i(realState[0]*cScaleFactor, realState[1]*cScaleFactor), </div><div class="line">                                  cv::Point2i(realState[0]*cScaleFactor, realState[1]*cScaleFactor) + cv::Point2i(cos(realState[2])*5*cScaleFactor, sin(realState[2])*5*cScaleFactor), </div><div class="line">                                  cv::Scalar(0,0,255), 2);</div><div class="line"></div><div class="line">      <span class="comment">// Draw robot</span></div><div class="line">      cv::arrowedLine(display,    cv::Point2i(medState[0]*cScaleFactor, medState[1]*cScaleFactor), </div><div class="line">                                  cv::Point2i(medState[0]*cScaleFactor, medState[1]*cScaleFactor) + cv::Point2i(cos(medState[2])*5*cScaleFactor, sin(medState[2])*5*cScaleFactor), </div><div class="line">                                  cv::Scalar(0,255,0), 2);</div><div class="line"></div><div class="line"></div><div class="line">      cv::imshow(<span class="stringliteral">&quot;display&quot;</span>, display);</div><div class="line">      cv::waitKey(3);</div><div class="line"></div><div class="line">      robot.simulate();</div><div class="line">      ObservationData obs = robot.observation();</div><div class="line">      filter.step(obs);</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>This is the example running: </p><div class="image">
<img src="pf_2d_simple.gif" alt="pf_2d_simple.gif"/>
</div>
<h1>Code snippets explained</h1>
<p>Header includes and constant for world size.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;opencv2/opencv.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;rgbd_tools/state_filtering/ParticleFilterCPU.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacergbd.html">rgbd</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> WORLD_SIZE = 300;</div></div><!-- fragment --><p>Function to generate random gaussian number. Particle filters works by sampling randomly variables. Thus adding noise to simulated robots is critical.</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> gauss(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp; _nu, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; _sigma) { </div><div class="line">  std::random_device rd; </div><div class="line">  std::mt19937 gen(rd()); </div><div class="line"></div><div class="line">  std::normal_distribution&lt;&gt; d(_nu, _sigma); </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> d(gen); </div><div class="line">} </div></div><!-- fragment --><p>Structure with observable variables. In this case, the distance to the origin of map and the angle of the robot are used. In a more complex example, other variables can be used as for example distance from laser/sonar sensors, images, features or landmarks.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ObservationData{</div><div class="line">  <span class="keywordtype">double</span> distanceOrigin = 0;</div><div class="line">  <span class="keywordtype">double</span> angle = 0;</div><div class="line">};</div></div><!-- fragment --><p>ParticleRobot class inherit from the ParticleInterface and is the class used for simulating the robot at each particle of the particle filter. The new class needs to implement two methods (which are abstract in the parent class): <code>void simulate()</code> and <code>double computeWeight(ObservationData &amp;_realObservation)</code>. The first method is responsible of simulating how the model updates over time. In this case, how the robot moves over time. The second method is responsible of computing an weight (or score) of how similar is the observation of the simulated particle and the real particle. This class is the most important. The of the Particle Filter and its resampling depend of its implementation.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ParticleRobot : <span class="keyword">public</span> ParticleInterface&lt;ObservationData&gt;{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ParticleRobot() {</div><div class="line">      mPosition[0] = gauss(WORLD_SIZE/2,25);</div><div class="line">      mPosition[1] = gauss(WORLD_SIZE/2,25);</div><div class="line">      mPosition[2] = gauss(0,1);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> simulate() { </div><div class="line">      mPosition[0] += 1*cos(mPosition[2]) + gauss(0,0.1);</div><div class="line">      mPosition[1] += 1*sin(mPosition[2]) + gauss(0,0.1);</div><div class="line">      mPosition[2] += gauss(0,0.05);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[0] &gt; WORLD_SIZE)</div><div class="line">          mPosition[0] = fmod(mPosition[0], WORLD_SIZE);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[0] &lt; 0)</div><div class="line">          mPosition[0] += WORLD_SIZE;</div><div class="line">      </div><div class="line">      <span class="keywordflow">if</span>(mPosition[1] &gt; WORLD_SIZE)</div><div class="line">          mPosition[1] = fmod(mPosition[1], WORLD_SIZE);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[1] &lt; 0)</div><div class="line">          mPosition[1] += WORLD_SIZE;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[2] &gt; M_PI*2)</div><div class="line">          mPosition[2] = fmod(mPosition[2], M_PI*2);</div><div class="line"></div><div class="line">          </div><div class="line">  };</div><div class="line"></div><div class="line">  ObservationData observation(){</div><div class="line">      <span class="keywordtype">double</span> xNoise = mPosition[0] + gauss(0,0.1);</div><div class="line">      <span class="keywordtype">double</span> yNoise = mPosition[1] + gauss(0,0.1);</div><div class="line"></div><div class="line">      ObservationData data;</div><div class="line">      data.distanceOrigin = sqrt(xNoise*xNoise + yNoise*yNoise);</div><div class="line">      data.angle = mPosition[2];</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> data;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> computeWeight(ObservationData &amp;_realObservation) {  </div><div class="line">      ObservationData fakeData = observation();</div><div class="line">      ObservationData realData = _realObservation;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> weightDistance = 1 - fabs(fakeData.distanceOrigin-realData.distanceOrigin)/WORLD_SIZE/2;</div><div class="line">      <span class="keywordtype">double</span> weightAngle = 1 - fabs(fakeData.angle - realData.angle)/(M_PI*2);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> weightAngle*weightDistance;</div><div class="line">  };</div><div class="line"></div><div class="line">  std::array&lt;double, 3&gt; position(){ <span class="keywordflow">return</span> mPosition; }</div><div class="line">  <span class="keyword">operator</span> std::array&lt;double, 3&gt;(){ <span class="keywordflow">return</span> mPosition; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::array&lt;double, 3&gt; mPosition;    <span class="comment">// x, y, ori</span></div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>Declaration of functions and main function that calls to the principle method.</p>
<div class="fragment"><div class="line">std::array&lt;double, 3&gt; mediumState(std::vector&lt;ParticleRobot&gt; _particles);</div><div class="line"><span class="keywordtype">void</span> particleFilterCPU();</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){</div><div class="line">  </div><div class="line">  particleFilterCPU();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Finished&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Method that computes the average values of state variables of the robot.</p>
<div class="fragment"><div class="line">std::array&lt;double, 3&gt; mediumState(std::vector&lt;ParticleRobot&gt; _particles){</div><div class="line">  std::array&lt;double, 3&gt; position = {0.0, 0.0, 0.0};</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; _particles.size(); i++){</div><div class="line">      std::array&lt;double, 3&gt; pos = _particles[i];</div><div class="line">      position[0] += pos[0];</div><div class="line">      position[1] += pos[1];</div><div class="line">      position[2] += pos[2];</div><div class="line">  }</div><div class="line">  position[0] /= _particles.size();</div><div class="line">  position[1] /= _particles.size();</div><div class="line">  position[2] /= _particles.size();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> position;</div><div class="line">}</div></div><!-- fragment --><p>This method initializes a particle filter using ParticleRobot class and ObservationData structure with one thousand particles. Once the filter is initilized it endlessly performs simulation and draw the result using OpenCV.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> particleFilterCPU() {</div><div class="line"></div><div class="line">  ParticleFilterCPU&lt;ParticleRobot, ObservationData&gt; filter(1000);</div><div class="line">  filter.init();</div><div class="line"></div><div class="line">  ParticleRobot robot;</div><div class="line">  <span class="keywordtype">double</span> time = 0.0;</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> cScaleFactor=1;</div><div class="line"></div><div class="line">  cv::namedWindow(<span class="stringliteral">&quot;display&quot;</span>, CV_WINDOW_FREERATIO);</div><div class="line">  <span class="keywordflow">for</span> (;;) {</div><div class="line">      std::array&lt;double, 3&gt; medState = mediumState(filter.particles());</div><div class="line">      std::array&lt;double, 3&gt; realState = robot.position();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;-------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Real state. X:&quot;</span> &lt;&lt; realState[0] &lt;&lt; <span class="stringliteral">&quot; ; Y: &quot;</span> &lt;&lt; realState[1] &lt;&lt; <span class="stringliteral">&quot; ; Ori: &quot;</span> &lt;&lt; realState[2] &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Promediate state. X:&quot;</span> &lt;&lt; medState[0] &lt;&lt; <span class="stringliteral">&quot; ; Y: &quot;</span> &lt;&lt; medState[1] &lt;&lt; <span class="stringliteral">&quot; ; Ori: &quot;</span> &lt;&lt; medState[2] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      cv::Mat display(WORLD_SIZE, WORLD_SIZE, CV_8UC3, cv::Scalar(0,0,0));</div><div class="line">      <span class="comment">// Draw landmarks</span></div><div class="line">      </div><div class="line">      cv::circle(display, cv::Point2i(WORLD_SIZE/2, WORLD_SIZE/2), 3, cv::Scalar(0,0,255), 3);</div><div class="line"></div><div class="line">      <span class="comment">// Draw particles</span></div><div class="line">      <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;particle: filter.particles()){</div><div class="line">          std::array&lt;double, 3&gt; pos = particle;</div><div class="line">          cv::arrowedLine(display,    cv::Point2i(pos[0]*cScaleFactor, pos[1]*cScaleFactor), </div><div class="line">                                      cv::Point2i(pos[0]*cScaleFactor, pos[1]*cScaleFactor) + cv::Point2i(cos(realState[2])*5*cScaleFactor, sin(realState[2])*5*cScaleFactor), </div><div class="line">                                      cv::Scalar(255,0,0), 1);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// Draw robot</span></div><div class="line">      cv::arrowedLine(display,    cv::Point2i(realState[0]*cScaleFactor, realState[1]*cScaleFactor), </div><div class="line">                                  cv::Point2i(realState[0]*cScaleFactor, realState[1]*cScaleFactor) + cv::Point2i(cos(realState[2])*5*cScaleFactor, sin(realState[2])*5*cScaleFactor), </div><div class="line">                                  cv::Scalar(0,0,255), 2);</div><div class="line"></div><div class="line">      <span class="comment">// Draw robot</span></div><div class="line">      cv::arrowedLine(display,    cv::Point2i(medState[0]*cScaleFactor, medState[1]*cScaleFactor), </div><div class="line">                                  cv::Point2i(medState[0]*cScaleFactor, medState[1]*cScaleFactor) + cv::Point2i(cos(medState[2])*5*cScaleFactor, sin(medState[2])*5*cScaleFactor), </div><div class="line">                                  cv::Scalar(0,255,0), 2);</div><div class="line"></div><div class="line"></div><div class="line">      cv::imshow(<span class="stringliteral">&quot;display&quot;</span>, display);</div><div class="line">      cv::waitKey(3);</div><div class="line"></div><div class="line">      robot.simulate();</div><div class="line">      ObservationData obs = robot.observation();</div><div class="line">      filter.step(obs);</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
