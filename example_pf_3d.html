<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>rgbd_tools: Setting up a simple Particle Filter for a random 3D mobile target.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rgbd_tools
   </div>
   <div id="projectbrief">General purpose tools for stereo devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Setting up a simple Particle Filter for a random 3D mobile target. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page shows how to use the abstract templatized implementation of the Particle Filter state estimation from RGBD_TOOLS. Particle Filteri is a Sequential Monte Carlo nonlinear estate estimator. For deeper understanding it is recomended to dig on internet. A good tutorial can be found in the following <a href="https://www.youtube.com/watch?v=4S-sx5_cmLU">link</a></p>
<p>RGBD_TOOLS implements a class that implement's the particle filter algorithm for CPU called ParticleFilterCPU. It is a templatized class that performs the simulation of the particles and the resampling methods. Particles are required to inherit from ParticleInterface abstract class. The observation structure can be of anykind and is part is the second template of the ParticleFilterCPU class.</p>
<p>In this tutorial, a simple target which moves in one direction is tracked. In order to estimate the underlaying state. Eight landmarks are placed in the world and the observation state is the distance to these landmarks. One thousand particles are simulated and then the medium value of the of the particles is used as the estimation. Additionally, the covariance is estimated using a gaussian distribution.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;rgbd_tools/state_filtering/ParticleFilterCPU.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;pcl/visualization/pcl_visualizer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Eigen/Eigen&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacergbd.html">rgbd</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> WORLD_SIZE = 5;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> gauss(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp; _nu, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; _sigma) { </div><div class="line">  std::random_device rd; </div><div class="line">  std::mt19937 gen(rd()); </div><div class="line"></div><div class="line">  std::normal_distribution&lt;&gt; d(_nu, _sigma); </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> d(gen); </div><div class="line">} </div><div class="line"></div><div class="line"><span class="keywordtype">double</span> LANDMARK_DIST = 5;</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;Eigen::Vector3f&gt; LANDMARKS = {</div><div class="line">  {LANDMARK_DIST,LANDMARK_DIST,LANDMARK_DIST},</div><div class="line">  {LANDMARK_DIST,LANDMARK_DIST,-LANDMARK_DIST},</div><div class="line">  {LANDMARK_DIST,-LANDMARK_DIST,-LANDMARK_DIST},</div><div class="line">  {-LANDMARK_DIST,-LANDMARK_DIST,-LANDMARK_DIST},</div><div class="line">  {LANDMARK_DIST,-LANDMARK_DIST,LANDMARK_DIST},</div><div class="line">  {-LANDMARK_DIST,-LANDMARK_DIST,LANDMARK_DIST},</div><div class="line">  {-LANDMARK_DIST,LANDMARK_DIST,LANDMARK_DIST},</div><div class="line">  {-LANDMARK_DIST,LANDMARK_DIST,-LANDMARK_DIST}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> N_LANDMARKS =  8;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>ObservationData{</div><div class="line">  std::vector&lt;float&gt;distLandmarks;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ParticleRobot : <span class="keyword">public</span> <a class="code" href="classrgbd_1_1_particle_interface.html">ParticleInterface</a>&lt;ObservationData&gt;{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> sign(<span class="keywordtype">float</span> _x){</div><div class="line">      <span class="keywordflow">return</span> _x &lt; 0? -1:1;</div><div class="line">  }</div><div class="line"></div><div class="line">  ParticleRobot() {</div><div class="line">      mPosition[0] = gauss(0,2);</div><div class="line">      mPosition[1] = gauss(0,2);</div><div class="line">      mPosition[2] = gauss(0,2);</div><div class="line">      mSpeed[0] = gauss(0,1);</div><div class="line">      mSpeed[1] = gauss(0,1);</div><div class="line">      mSpeed[2] = gauss(0,1);</div><div class="line"></div><div class="line">      mSpeed[0] = fabs(mSpeed[0]) &gt; 0.5? sign(mSpeed[0])*0.5 : mSpeed[0];</div><div class="line">      mSpeed[1] = fabs(mSpeed[1]) &gt; 0.5? sign(mSpeed[1])*0.5 : mSpeed[1];</div><div class="line">      mSpeed[2] = fabs(mSpeed[2]) &gt; 0.5? sign(mSpeed[2])*0.5 : mSpeed[2];</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> simulate() { </div><div class="line">      mPosition[0] += mSpeed[0]*0.06;</div><div class="line">      mPosition[1] += mSpeed[1]*0.06;</div><div class="line">      mPosition[2] += mSpeed[2]*0.06;</div><div class="line"></div><div class="line"></div><div class="line">      mSpeed[0] += gauss(0,0.2);</div><div class="line">      mSpeed[1] += gauss(0,0.2);</div><div class="line">      mSpeed[2] += gauss(0,0.2);</div><div class="line"></div><div class="line">      mSpeed[0] = fabs(mSpeed[0]) &gt; 1.0? sign(mSpeed[0])*1.0 : mSpeed[0];</div><div class="line">      mSpeed[1] = fabs(mSpeed[1]) &gt; 1.0? sign(mSpeed[1])*1.0 : mSpeed[1];</div><div class="line">      mSpeed[2] = fabs(mSpeed[2]) &gt; 1.0? sign(mSpeed[2])*1.0 : mSpeed[2];</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[0] &gt; WORLD_SIZE)</div><div class="line">          mPosition[0] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[0] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[0] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[1] &gt; WORLD_SIZE)</div><div class="line">          mPosition[1] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[1] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[1] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[2] &gt; WORLD_SIZE)</div><div class="line">          mPosition[2] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[2] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[2] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> simulateReal() { </div><div class="line">      mPosition[0] += mSpeed[0]*0.06;</div><div class="line">      mPosition[1] += mSpeed[1]*0.06;</div><div class="line">      mPosition[2] += mSpeed[2]*0.06;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[0] &gt; WORLD_SIZE)</div><div class="line">          mPosition[0] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[0] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[0] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[1] &gt; WORLD_SIZE)</div><div class="line">          mPosition[1] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[1] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[1] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[2] &gt; WORLD_SIZE)</div><div class="line">          mPosition[2] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[2] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[2] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">  };</div><div class="line"></div><div class="line">  ObservationData observation(){</div><div class="line">      ObservationData data;</div><div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; LANDMARKS.size(); i++){</div><div class="line">          data.distLandmarks.push_back((mPosition - LANDMARKS[i]).norm() + gauss(0,0.2));</div><div class="line">      }</div><div class="line">      </div><div class="line">      <span class="keywordflow">return</span> data;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> computeWeight(ObservationData &amp;_observation) {  </div><div class="line">      ObservationData fakeData = observation();</div><div class="line">      ObservationData realData = _observation;</div><div class="line"></div><div class="line">      std::vector&lt;float&gt; distanceWeights;</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> score = 1;</div><div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; fakeData.distLandmarks.size(); i++){</div><div class="line">          score *= 1 - fabs(fakeData.distLandmarks[i] - realData.distLandmarks[i])/(WORLD_SIZE*2);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> score;</div><div class="line">  };</div><div class="line"></div><div class="line">  Eigen::Vector3f position(){ <span class="keywordflow">return</span> mPosition; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Eigen::Vector3f mPosition;  <span class="comment">// x, y, z</span></div><div class="line">  Eigen::Vector3f mSpeed; <span class="comment">// x, y, z</span></div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">//---------------------------------------------------------------------------------------------------------------------</span></div><div class="line">Eigen::Vector3f mediumState(std::vector&lt;ParticleRobot&gt; _particles);</div><div class="line"><span class="keywordtype">void</span> particleFilterCPU();</div><div class="line"></div><div class="line"><span class="comment">//---------------------------------------------------------------------------------------------------------------------</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){</div><div class="line">  </div><div class="line">  particleFilterCPU();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Finished&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//---------------------------------------------------------------------------------------------------------------------</span></div><div class="line"></div><div class="line">Eigen::Vector3f mediumState(std::vector&lt;ParticleRobot&gt; _particles){</div><div class="line">  Eigen::Vector3f position = {0.0, 0.0, 0.0};</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; _particles.size(); i++){</div><div class="line">      Eigen::Vector3f pos = _particles[i].position();</div><div class="line">      position[0] += pos[0];</div><div class="line">      position[1] += pos[1];</div><div class="line">      position[2] += pos[2];</div><div class="line">  }</div><div class="line">  position[0] /= _particles.size();</div><div class="line">  position[1] /= _particles.size();</div><div class="line">  position[2] /= _particles.size();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> position;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> particleFilterCPU() {</div><div class="line"></div><div class="line">  <a class="code" href="classrgbd_1_1_particle_filter_c_p_u.html">ParticleFilterCPU&lt;ParticleRobot, ObservationData&gt;</a> filter(1000); </div><div class="line">  filter.init();</div><div class="line"></div><div class="line">  ParticleRobot robot;</div><div class="line">  <span class="keywordtype">double</span> time = 0.0;</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> cScaleFactor=1;</div><div class="line"></div><div class="line">  pcl::visualization::PCLVisualizer viewer (<span class="stringliteral">&quot;viewer&quot;</span>);</div><div class="line"></div><div class="line">  viewer.addCoordinateSystem(0.2);</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (;;) {</div><div class="line">      Eigen::Vector3f medState = mediumState(filter.particles());</div><div class="line">      Eigen::Vector3f realState = robot.position();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;-------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Real state. X:&quot;</span> &lt;&lt; realState[0] &lt;&lt; <span class="stringliteral">&quot; ; Y: &quot;</span> &lt;&lt; realState[1] &lt;&lt; <span class="stringliteral">&quot; ; Z: &quot;</span> &lt;&lt; realState[2] &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Promediate state. X:&quot;</span> &lt;&lt; medState[0] &lt;&lt; <span class="stringliteral">&quot; ; Y: &quot;</span> &lt;&lt; medState[1] &lt;&lt; <span class="stringliteral">&quot; ; Z: &quot;</span> &lt;&lt; medState[2] &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Error. X:&quot;</span> &lt;&lt; fabs(realState[0] - medState[0]) &lt;&lt; <span class="stringliteral">&quot; ; Y: &quot;</span> &lt;&lt; fabs(realState[1] - medState[1]) &lt;&lt; <span class="stringliteral">&quot; ; Z: &quot;</span> &lt;&lt; fabs(realState[2] -  medState[2]) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      viewer.removeAllShapes();</div><div class="line">      viewer.removeAllPointClouds();</div><div class="line">      <span class="comment">// Draw landmarks</span></div><div class="line">      <span class="keywordtype">int</span> counter = 0;</div><div class="line">      <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;lm: LANDMARKS){</div><div class="line">          viewer.addSphere(pcl::PointXYZ(lm[0],lm[1],lm[2]),0.15, 1,0,0,<span class="stringliteral">&quot;sphere&quot;</span>+std::to_string(counter++));</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// Draw particles</span></div><div class="line">      pcl::PointCloud&lt;pcl::PointXYZRGB&gt; particles;</div><div class="line">      <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;particle: filter.particles()){</div><div class="line">          pcl::PointXYZRGB p (0,0,255);</div><div class="line"></div><div class="line">          Eigen::Vector3f pos = particle.position();</div><div class="line">          </div><div class="line">          p.x = pos[0];</div><div class="line">          p.y = pos[1];</div><div class="line">          p.z = pos[2];</div><div class="line">          particles.push_back(p);</div><div class="line">      }</div><div class="line">      viewer.addPointCloud(particles.makeShared(), <span class="stringliteral">&quot;cloud_particles&quot;</span>);</div><div class="line">      viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 5, <span class="stringliteral">&quot;cloud_particles&quot;</span>);</div><div class="line">          </div><div class="line"></div><div class="line">      <span class="comment">// Draw robot</span></div><div class="line">      viewer.addSphere(pcl::PointXYZ(realState[0],realState[1],realState[2]),0.2, 1,0,0,<span class="stringliteral">&quot;sphere&quot;</span>+std::to_string(counter++));</div><div class="line"></div><div class="line">      <span class="comment">// Estimate</span></div><div class="line">      viewer.addSphere(pcl::PointXYZ(medState[0],medState[1],medState[2]),0.2, 0,1,0,<span class="stringliteral">&quot;sphere&quot;</span>+std::to_string(counter++));</div><div class="line"></div><div class="line"></div><div class="line">      viewer.spinOnce(30);</div><div class="line">      std::this_thread::sleep_for(std::chrono::milliseconds(30));</div><div class="line"></div><div class="line">      robot.simulateReal();</div><div class="line">      ObservationData obs = robot.observation();</div><div class="line">      filter.step(obs);</div><div class="line"></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>This is the example running: </p><div class="image">
<img src="pf_3d_simple.gif" alt="pf_3d_simple.gif"/>
</div>
<h1>Code snippets explained</h1>
<p>Various includes needed, namespaces and definition of world's size</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;rgbd_tools/state_filtering/ParticleFilterCPU.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;Eigen/Eigen&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pcl/visualization/pcl_visualizer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacergbd.html">rgbd</a>;</div><div class="line">       </div><div class="line"><span class="keywordtype">int</span> WORLD_SIZE = 5;</div></div><!-- fragment --><p>Random gaussian number generation wrapper for particles</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> gauss(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp; _nu, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; _sigma) { </div><div class="line">  std::random_device rd; </div><div class="line">  std::mt19937 gen(rd()); </div><div class="line"></div><div class="line">  std::normal_distribution&lt;&gt; d(_nu, _sigma); </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> d(gen); </div><div class="line">} </div></div><!-- fragment --><p>Definition of landmarks used to locate the robot</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> LANDMARK_DIST = 5;</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;Eigen::Vector3f&gt; LANDMARKS = {</div><div class="line">  {LANDMARK_DIST,LANDMARK_DIST,LANDMARK_DIST},</div><div class="line">  {LANDMARK_DIST,LANDMARK_DIST,-LANDMARK_DIST},</div><div class="line">  {LANDMARK_DIST,-LANDMARK_DIST,-LANDMARK_DIST},</div><div class="line">  {-LANDMARK_DIST,-LANDMARK_DIST,-LANDMARK_DIST},</div><div class="line">  {LANDMARK_DIST,-LANDMARK_DIST,LANDMARK_DIST},</div><div class="line">  {-LANDMARK_DIST,-LANDMARK_DIST,LANDMARK_DIST},</div><div class="line">  {-LANDMARK_DIST,LANDMARK_DIST,LANDMARK_DIST},</div><div class="line">  {-LANDMARK_DIST,LANDMARK_DIST,-LANDMARK_DIST}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> N_LANDMARKS =  8;</div></div><!-- fragment --><p>Definition of the observation data</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ObservationData{</div><div class="line">  std::vector&lt;float&gt;distLandmarks;</div><div class="line">};</div></div><!-- fragment --><p>Definition of particle class. Each particle is created in a random position and a random speed is assigned. The speed of the robot is is limitted to 0.5. In this code, the simulated behaviour is separated from the real behaviour. A class that inherits from ParticleInterface needs to implement the "void simulate()" method, which is used by the particle filter to simulate particles. In this method, noise has been added to the speed of the particles to avoid particles to converge to a wrong state. Another method has been coded which is used only to update the real state of the target which is called "void simulateReal()" the object that uses this method does not vary its speed. The "ObservationData observation()" method internally used to compute the observed data. Finally, the "double computeWeight(ObservationData _observation)" method is required to resample particles according to the real observed data.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ParticleRobot : <span class="keyword">public</span> ParticleInterface&lt;ObservationData&gt;{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> sign(<span class="keywordtype">float</span> _x){</div><div class="line">      <span class="keywordflow">return</span> _x &lt; 0? -1:1;</div><div class="line">  }</div><div class="line"></div><div class="line">  ParticleRobot() {</div><div class="line">      mPosition[0] = gauss(0,2);</div><div class="line">      mPosition[1] = gauss(0,2);</div><div class="line">      mPosition[2] = gauss(0,2);</div><div class="line">      mSpeed[0] = gauss(0,1);</div><div class="line">      mSpeed[1] = gauss(0,1);</div><div class="line">      mSpeed[2] = gauss(0,1);</div><div class="line"></div><div class="line">      mSpeed[0] = fabs(mSpeed[0]) &gt; 0.5? sign(mSpeed[0])*0.5 : mSpeed[0];</div><div class="line">      mSpeed[1] = fabs(mSpeed[1]) &gt; 0.5? sign(mSpeed[1])*0.5 : mSpeed[1];</div><div class="line">      mSpeed[2] = fabs(mSpeed[2]) &gt; 0.5? sign(mSpeed[2])*0.5 : mSpeed[2];</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> simulate() { </div><div class="line">      mPosition[0] += mSpeed[0]*0.06;</div><div class="line">      mPosition[1] += mSpeed[1]*0.06;</div><div class="line">      mPosition[2] += mSpeed[2]*0.06;</div><div class="line"></div><div class="line"></div><div class="line">      mSpeed[0] += gauss(0,0.2);</div><div class="line">      mSpeed[1] += gauss(0,0.2);</div><div class="line">      mSpeed[2] += gauss(0,0.2);</div><div class="line"></div><div class="line">      mSpeed[0] = fabs(mSpeed[0]) &gt; 1.0? sign(mSpeed[0])*1.0 : mSpeed[0];</div><div class="line">      mSpeed[1] = fabs(mSpeed[1]) &gt; 1.0? sign(mSpeed[1])*1.0 : mSpeed[1];</div><div class="line">      mSpeed[2] = fabs(mSpeed[2]) &gt; 1.0? sign(mSpeed[2])*1.0 : mSpeed[2];</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[0] &gt; WORLD_SIZE)</div><div class="line">          mPosition[0] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[0] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[0] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[1] &gt; WORLD_SIZE)</div><div class="line">          mPosition[1] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[1] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[1] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[2] &gt; WORLD_SIZE)</div><div class="line">          mPosition[2] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[2] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[2] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> simulateReal() { </div><div class="line">      mPosition[0] += mSpeed[0]*0.06;</div><div class="line">      mPosition[1] += mSpeed[1]*0.06;</div><div class="line">      mPosition[2] += mSpeed[2]*0.06;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[0] &gt; WORLD_SIZE)</div><div class="line">          mPosition[0] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[0] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[0] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[1] &gt; WORLD_SIZE)</div><div class="line">          mPosition[1] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[1] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[1] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span>(mPosition[2] &gt; WORLD_SIZE)</div><div class="line">          mPosition[2] -= WORLD_SIZE*2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPosition[2] &lt; -WORLD_SIZE)</div><div class="line">          mPosition[2] += WORLD_SIZE*2;</div><div class="line"></div><div class="line">  };</div><div class="line"></div><div class="line">  ObservationData observation(){</div><div class="line">      ObservationData data;</div><div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; LANDMARKS.size(); i++){</div><div class="line">          data.distLandmarks.push_back((mPosition - LANDMARKS[i]).norm() + gauss(0,0.2));</div><div class="line">      }</div><div class="line">      </div><div class="line">      <span class="keywordflow">return</span> data;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> computeWeight(ObservationData &amp;_observation) {  </div><div class="line">      ObservationData fakeData = observation();</div><div class="line">      ObservationData realData = _observation;</div><div class="line"></div><div class="line">      std::vector&lt;float&gt; distanceWeights;</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> score = 1;</div><div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; fakeData.distLandmarks.size(); i++){</div><div class="line">          score *= 1 - fabs(fakeData.distLandmarks[i] - realData.distLandmarks[i])/(WORLD_SIZE*2);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> score;</div><div class="line">  };</div><div class="line"></div><div class="line">  Eigen::Vector3f position(){ <span class="keywordflow">return</span> mPosition; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Eigen::Vector3f mPosition;  <span class="comment">// x, y, z</span></div><div class="line">  Eigen::Vector3f mSpeed; <span class="comment">// x, y, z</span></div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>Declaration of functions and main function.</p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------------------------------------------------</span></div><div class="line">Eigen::Vector3f mediumState(std::vector&lt;ParticleRobot&gt; _particles);</div><div class="line"><span class="keywordtype">void</span> particleFilterCPU();</div><div class="line"></div><div class="line"><span class="comment">//---------------------------------------------------------------------------------------------------------------------</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){</div><div class="line">  </div><div class="line">  particleFilterCPU();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Finished&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Method to compute the medium value of the particles to use it as estimate.</p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------------------------------------------------</span></div><div class="line"></div><div class="line">Eigen::Vector3f mediumState(std::vector&lt;ParticleRobot&gt; _particles){</div><div class="line">  Eigen::Vector3f position = {0.0, 0.0, 0.0};</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; _particles.size(); i++){</div><div class="line">      Eigen::Vector3f pos = _particles[i].position();</div><div class="line">      position[0] += pos[0];</div><div class="line">      position[1] += pos[1];</div><div class="line">      position[2] += pos[2];</div><div class="line">  }</div><div class="line">  position[0] /= _particles.size();</div><div class="line">  position[1] /= _particles.size();</div><div class="line">  position[2] /= _particles.size();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> position;</div><div class="line">}</div></div><!-- fragment --><p>Function that moves the real robot and performs the particle filter at each step. At first, the particle filter is created with the appropiate templates <code>ParticleFilterCPU&lt;ParticleRobot, ObservationData&gt; filter(1000)</code> and then initialized <code>filter.init()</code>. A real robot is created using the same class for simplicity <code>ParticleRobot robot;</code>. At each step, the data is ploted in a <code>pcl::visualization::PCLVisualizer</code>. The real robot is simulated by <code>robot.simulateReal()</code> and its observation acquired <code>ObservationData obs = robot.observation()</code>. This observation is used by the particle filter to update the particles (<code>filter.step(obs)</code>) which then are used to estimate the real state.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> particleFilterCPU() {</div><div class="line"></div><div class="line">  ParticleFilterCPU&lt;ParticleRobot, ObservationData&gt; filter(1000); </div><div class="line">  filter.init();</div><div class="line"></div><div class="line">  ParticleRobot robot;</div><div class="line">  <span class="keywordtype">double</span> time = 0.0;</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> cScaleFactor=1;</div><div class="line"></div><div class="line">  pcl::visualization::PCLVisualizer viewer (<span class="stringliteral">&quot;viewer&quot;</span>);</div><div class="line"></div><div class="line">  viewer.addCoordinateSystem(0.2);</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (;;) {</div><div class="line">      Eigen::Vector3f medState = mediumState(filter.particles());</div><div class="line">      Eigen::Vector3f realState = robot.position();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;-------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Real state. X:&quot;</span> &lt;&lt; realState[0] &lt;&lt; <span class="stringliteral">&quot; ; Y: &quot;</span> &lt;&lt; realState[1] &lt;&lt; <span class="stringliteral">&quot; ; Z: &quot;</span> &lt;&lt; realState[2] &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Promediate state. X:&quot;</span> &lt;&lt; medState[0] &lt;&lt; <span class="stringliteral">&quot; ; Y: &quot;</span> &lt;&lt; medState[1] &lt;&lt; <span class="stringliteral">&quot; ; Z: &quot;</span> &lt;&lt; medState[2] &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Error. X:&quot;</span> &lt;&lt; fabs(realState[0] - medState[0]) &lt;&lt; <span class="stringliteral">&quot; ; Y: &quot;</span> &lt;&lt; fabs(realState[1] - medState[1]) &lt;&lt; <span class="stringliteral">&quot; ; Z: &quot;</span> &lt;&lt; fabs(realState[2] -  medState[2]) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      viewer.removeAllShapes();</div><div class="line">      viewer.removeAllPointClouds();</div><div class="line">      <span class="comment">// Draw landmarks</span></div><div class="line">      <span class="keywordtype">int</span> counter = 0;</div><div class="line">      <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;lm: LANDMARKS){</div><div class="line">          viewer.addSphere(pcl::PointXYZ(lm[0],lm[1],lm[2]),0.15, 1,0,0,<span class="stringliteral">&quot;sphere&quot;</span>+std::to_string(counter++));</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// Draw particles</span></div><div class="line">      pcl::PointCloud&lt;pcl::PointXYZRGB&gt; particles;</div><div class="line">      <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;particle: filter.particles()){</div><div class="line">          pcl::PointXYZRGB p (0,0,255);</div><div class="line"></div><div class="line">          Eigen::Vector3f pos = particle.position();</div><div class="line">          </div><div class="line">          p.x = pos[0];</div><div class="line">          p.y = pos[1];</div><div class="line">          p.z = pos[2];</div><div class="line">          particles.push_back(p);</div><div class="line">      }</div><div class="line">      viewer.addPointCloud(particles.makeShared(), <span class="stringliteral">&quot;cloud_particles&quot;</span>);</div><div class="line">      viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 5, <span class="stringliteral">&quot;cloud_particles&quot;</span>);</div><div class="line">          </div><div class="line"></div><div class="line">      <span class="comment">// Draw robot</span></div><div class="line">      viewer.addSphere(pcl::PointXYZ(realState[0],realState[1],realState[2]),0.2, 1,0,0,<span class="stringliteral">&quot;sphere&quot;</span>+std::to_string(counter++));</div><div class="line"></div><div class="line">      <span class="comment">// Estimate</span></div><div class="line">      viewer.addSphere(pcl::PointXYZ(medState[0],medState[1],medState[2]),0.2, 0,1,0,<span class="stringliteral">&quot;sphere&quot;</span>+std::to_string(counter++));</div><div class="line"></div><div class="line"></div><div class="line">      viewer.spinOnce(30);</div><div class="line">      std::this_thread::sleep_for(std::chrono::milliseconds(30));</div><div class="line"></div><div class="line">      robot.simulateReal();</div><div class="line">      ObservationData obs = robot.observation();</div><div class="line">      filter.step(obs);</div><div class="line"></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
